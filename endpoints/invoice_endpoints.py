from fastapi import APIRouter, Depends, BackgroundTasks
from sqlmodel import select, col
from starlette.responses import JSONResponse

from base_models.invoices import InvoiceByDate, FetchStatus
from models import (Institution, Session, Invoice, InvoiceBase, InvoiceNote, EntryPeriod, Contract,
                    EmployeeEntry)
from fastapi import status, UploadFile
from database import get_session,engine
from auth import AuthHandler
import shutil
import os
from fastapi.responses import FileResponse
from datetime import datetime, timedelta,date

from utils.excel import generate_excel
from utils.invoice_helper import update_invoice_amount
from invoice_report import fetch_list_of_employee_entries__service_and_entry_period
import json

invoice_router = APIRouter(tags=["Invoice"])

auth_handler = AuthHandler()


@invoice_router.get('/invoices_between_dates')
async def fetch_invoices_between_dates(bg_tasks: BackgroundTasks, fetch_status: FetchStatus,
                                       session: Session = Depends(get_session),
                                       start_date: date = date(1970, 1, 1),
                                       end_date: date = date.today(),
                                       user=Depends(auth_handler.get_current_user)):
    """ Endpoint to Return Invoices between dates """

    try:
       
        """ Get all entry periods between start date and end date """
        entry_stmt = select(EntryPeriod).where(
            ((EntryPeriod.startDate >= start_date) | (EntryPeriod.endDate <= end_date)),
            EntryPeriod.deletedStatus == False)
        entry_period_list = session.exec(entry_stmt).all()
        entry_periods = [ent_period.id for ent_period in entry_period_list]
        """ Get all invoices that was generated by above entry period list """
        statement = select(Invoice).where(col(Invoice.id).in_(entry_periods),
                                          Invoice.deletedStatus == False)
        result = session.exec(statement).all()

        if len(result) < 1:
            return JSONResponse(
                content=f'There are no invoices from {start_date.date()} to {end_date.date()}!',
                status_code=status.HTTP_200_OK)
        excel_export = []
        for i in result:
            invoice_num = i.invoice_number
            inst_id = [p.institution_id for p in entry_period_list if p.id == i.entry_period_id]
            """ Get Institution which the invoice belongs to """
            institution = session.exec(select(Institution).where(Institution.id == inst_id[0],
                                                                 Institution.deletedStatus == False)).first()
            """ Get Institution's active contract """
            contract = session.exec(select(Contract).where(Contract.institution_id == inst_id[0],
                                                            Contract.current == True,
                                                            Contract.deletedStatus == False)).first()
            unit_price=1
                
            """ Get Invoice's entry period data """
            entry_period = session.exec(
                select(EntryPeriod).where(EntryPeriod.id == i.entry_period_id,
                                          EntryPeriod.deletedStatus == False)).first()
            """ Get all entries signed within the above entry period """
            emp_entry_statement = select(EmployeeEntry).where(
                EmployeeEntry.entry_period_id == i.entry_period_id,
                EmployeeEntry.deletedStatus == False, EmployeeEntry.signed == True)
            entries = session.exec(emp_entry_statement).all()
            if len(entries) > 0:
                service_rate=[]
                if institution.rate_type == "Universal":
                    for en in entries:
                        if not contract is None:
                            if not contract.services is None:
                                for s in contract.services:
                                    if s['service_id']==en.service_id:
                                        data={'rate':s['service_rate']}
                                        service_rate.append(data)
                                        rat=str(service_rate)
                                        unit_price=rat

                            else:
                                if contract.rate:
                                    unit_price=float(contract.rate)

                    unitPrice = unit_price
                num_of_attendance = len(entries)
                excel_export.append(InvoiceByDate(rate=unitPrice, total=i.total_amount,
                                                      start_date=entry_period.startDate,
                                                      end_date=entry_period.endDate,
                                                      invoice_number=invoice_num,
                                                      institution_name=institution.name,
                                                      number_of_attendance=num_of_attendance))
        excel_export.sort(key=lambda x: x.start_date)
        if fetch_status == FetchStatus.download:
            headers = ['inv #', 'start date', 'end date', 'institution', '# of attendance', 'rate',
                       'total']
            file_name = f"{start_date}_{end_date}"
            generate_excel(excel_export, headers, file_name)
            headers = {'Content-Disposition': f'attachment; filename="{file_name}.xlsx"'}
            file_path = os.getcwd() + "/" + f'{file_name}.xlsx'

            bg_tasks.add_task(os.remove, file_path)
            return FileResponse(path=file_path, media_type='application/octet-stream',
                                filename=f'{file_name}.xlsx', headers=headers, background=bg_tasks)
        return excel_export

    except Exception as e:
        print(e)
        return JSONResponse(content="Error: " + str(e),
                            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR)


@invoice_router.get('/update_all_invoices')
async def update_invoices(session: Session = Depends(get_session),
                          user=Depends(auth_handler.get_current_user)):
    """ Endpoint to Update all invoices total amount """

    try:
        """ Get all invoices """
        statement = select(Invoice).where(Invoice.deletedStatus == False)
        result = session.exec(statement).all()

        if len(result) < 1:
            return JSONResponse(content=f'There are no invoices', status_code=status.HTTP_200_OK)
        for i in result:
            """ Get Invoice's entry period data """
            entry_period = session.exec(
                select(EntryPeriod).where(EntryPeriod.id == i.entry_period_id,
                                          EntryPeriod.deletedStatus == False)).first()
            """ Get Institution which the invoice belongs to """
            institution = session.exec(
                select(Institution).where(Institution.id == entry_period.institution_id,
                                          Institution.deletedStatus == False)).first()
            """ Get Institution's active contract """
            services = session.exec(
                select(Contract.services).where(Contract.institution_id == institution.id,
                                            Contract.current == True,
                                            Contract.deletedStatus == False)).first()
            """ Get all entries signed within the above entry period """
            emp_entry_statement = select(EmployeeEntry).where(
                EmployeeEntry.entry_period_id == i.entry_period_id,
                EmployeeEntry.deletedStatus == False, EmployeeEntry.signed == True)
            entries = session.exec(emp_entry_statement).all()
            if len(entries) > 0:
                if institution.rate_type == "Universal":
                    for s in services:
                        serv_rate=s['service_rate']
                        unitPrice = serv_rate
                        i.total_amount = update_invoice_amount(i.entry_period_id, float(unitPrice))
                        session.add(i)
            session.commit()
        return JSONResponse(content="All invoice's total amount updated successfully",
                            status_code=status.HTTP_200_OK)
    except Exception as e:
        print(e)
        return JSONResponse(content="Error: " + str(e),
                            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR)


@invoice_router.get('/invoices/{invoice_id}/')
async def fetch_invoice_detail(invoice_id: int, inv_session: Session = Depends(get_session),
                               user=Depends(auth_handler.get_current_user)):
    """ Endpoint to Return Invoice Detail """

    try:
        statement = select(Invoice).where(Invoice.id == invoice_id, Invoice.deletedStatus == False)
        result = inv_session.exec(statement).first()
        if result is not None:
            return result
        else:
            return JSONResponse(content=f"Invoice with {invoice_id} not found",
                                status_code=status.HTTP_404_NOT_FOUND)

    except Exception as e:
        print(e)
        return JSONResponse(content="Error: " + str(e),
                            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR)


@invoice_router.put('/invoices/{uuid}/change/status', response_model=Invoice)
async def change_invoice_status(uuid: str, inv: InvoiceBase,
                                inv_session: Session = Depends(get_session),
                                user=Depends(auth_handler.get_current_user)):
    """ Endpoint to change Invoice Payment Status  """

    try:
        statement = select(Invoice).where(Invoice.uuid == uuid, Invoice.deletedStatus == False)
        result = inv_session.exec(statement).first()

        if not result is None:
            status1 = 'Paid'
            if inv.payment_status == status1:
                result.payment_status = inv.payment_status
                result.payment_confirmed_at = datetime.now()
                result.payment_confirmed_by = user.userName
                inv_session.add(result)
                inv_session.commit()
                return result
            else:
                return JSONResponse(content="Unknown Status Given",
                                    status_code=status.HTTP_400_BAD_REQUEST)
        else:
            return JSONResponse(content="Invoice  Not Found", status_code=status.HTTP_404_NOT_FOUND)
    except Exception as e:
        print(e)
        return JSONResponse(content="Error: " + str(e),
                            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR)


@invoice_router.put('/invoices/{uuid}/add/notes/')
async def add_invoice_notes(uuid: str, inv: InvoiceNote,
                            inv_session: Session = Depends(get_session),
                            user=Depends(auth_handler.get_current_user)):
    """ Endpoint to Add  Invoice Notes """

    try:
        statement = select(Invoice).where(Invoice.uuid == uuid, Invoice.deletedStatus == False)
        result = inv_session.exec(statement).first()

        if not result is None:
            result.invoice_notes = inv.invoice_notes
            inv_session.add(result)
            inv_session.commit()
        else:
            return JSONResponse(content="Invoice with " + uuid + " Not Found",
                                status_code=status.HTTP_404_NOT_FOUND)
    except Exception as e:
        print(e)
        return JSONResponse(content="Error: " + str(e),
                            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR)


@invoice_router.get('/invoices/fetch/delayed/')
async def fetch_delayed_Invoice(inv_session: Session = Depends(get_session),
                                user=Depends(auth_handler.get_current_user)):
    """ Endpoint to Fetch All  Invoices """

    try:
        invoice_list = []
        statement = select(Invoice).where(Invoice.payment_status == 'Pending',
                                          Invoice.deletedStatus == False)
        result = inv_session.exec(statement).all()

        if not result is None:
            for r in result:
                period_statement = select(EntryPeriod).where(EntryPeriod.id == r.entry_period_id,
                                                             EntryPeriod.deletedStatus == False)
                entry_period = inv_session.exec(period_statement).first()
                if not entry_period is None:
                    ins_statement = select(Institution).where(
                        Institution.id == entry_period.institution_id,
                        Institution.deletedStatus == False)
                    institution = inv_session.exec(ins_statement).first()
                    if not institution is None:
                        cont_statement = select(Contract).where(
                            Contract.institution_id == institution.id,
                            Contract.deletedStatus == False)
                        contract = inv_session.exec(cont_statement).first()
                        if not contract is None:
                            if entry_period.endDate.date() + timedelta(
                                    days=contract.due_date_days) < datetime.now().date():
                                data = {'uuid': str(r.uuid), 'payment_status': r.payment_status,
                                        'payment_confirmed_at': str(r.payment_confirmed_at),
                                        'payment_confirmed_by': r.payment_confirmed_by,
                                        'total_amount': r.total_amount,
                                        'invoice_number': r.invoice_number,
                                        'institutionName': institution.name,
                                        'institutionEmail': institution.email,
                                        'phone': institution.phone, 'due_date': str(
                                        entry_period.endDate.date() + timedelta(
                                            days=contract.due_date_days)),
                                        'entry_period_id': str(entry_period.id)}
                                invoice_list.append(data)

            return invoice_list
        else:
            return JSONResponse(content="Invoices Not Found", status_code=status.HTTP_404_NOT_FOUND)
    except Exception as e:
        print(e)
        return JSONResponse(content="Error: " + str(e),
                            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR)


@invoice_router.get('/institutions/{institution_id}/invoices/fetch/delayed/')
async def fetch_institution_delayed_Invoice(institution_id: int,
                                            inv_session: Session = Depends(get_session),
                                            user=Depends(auth_handler.get_current_user)):
    """ Endpoint to Fetch All  Invoices """
    try:
        invoice_list = []
        statement = select(Invoice).where(Invoice.deletedStatus == False)
        result = inv_session.exec(statement).all()

        if not result is None:
            for r in result:
                period_statement = select(EntryPeriod).where(EntryPeriod.id == r.entry_period_id,
                                                             EntryPeriod.deletedStatus == False)
                entry_period = inv_session.exec(period_statement).first()
                if not entry_period is None and entry_period.institution_id == institution_id:
                    ins_statement = select(Institution).where(
                        Institution.id == entry_period.institution_id,
                        Institution.deletedStatus == False)
                    institution = inv_session.exec(ins_statement).first()
                    if not institution is None:
                        cont_statement = select(Contract).where(
                            Contract.institution_id == institution.id,
                            Contract.deletedStatus == False)
                        contract = inv_session.exec(cont_statement).first()
                        if not contract is None:
                            if entry_period.endDate.date() + timedelta(
                                    days=contract.due_date_days) < datetime.now().date():
                                data = {'uuid': str(r.uuid), 'payment_status': r.payment_status,
                                        'payment_confirmed_at': str(r.payment_confirmed_at),
                                        'payment_confirmed_by': r.payment_confirmed_by,
                                        'total_amount': r.total_amount,
                                        'invoice_number': r.invoice_number,
                                        'institutionName': institution.name,
                                        'institutionEmail': institution.email,
                                        'phone': institution.phone, 'due_date': str(
                                        entry_period.endDate.date() + timedelta(
                                            days=contract.due_date_days)),
                                        'entry_period_id': str(entry_period.id)}
                                invoice_list.append(data)

            return invoice_list
        else:
            return JSONResponse(content="Invoices Not Found", status_code=status.HTTP_404_NOT_FOUND)
    except Exception as e:
        print(e)
        return JSONResponse(content="Error: " + str(e),
                            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR)


@invoice_router.get('/institutions/{institution_id}/invoices/')
async def fetch_institution_invoices(institution_id: int,
                                     inv_session: Session = Depends(get_session),
                                     user=Depends(auth_handler.get_current_user)):
    """ Endpoint to Fetch All  Invoices """
    try:
        invoice_list = []
        statement = select(Invoice).where(Invoice.deletedStatus == False)
        result = inv_session.exec(statement).all()

        if not result is None:
            for r in result:
                period_statement = select(EntryPeriod).where(EntryPeriod.id == r.entry_period_id,
                                                             EntryPeriod.deletedStatus == False)
                entry_period = inv_session.exec(period_statement).first()
                if not entry_period is None and entry_period.institution_id == institution_id:
                    ins_statement = select(Institution).where(
                        Institution.id == entry_period.institution_id,
                        Institution.deletedStatus == False)
                    institution = inv_session.exec(ins_statement).first()
                    if not institution is None:
                        cont_statement = select(Contract).where(
                            Contract.institution_id == institution.id,
                            Contract.deletedStatus == False)
                        contract = inv_session.exec(cont_statement).first()
                        if not contract is None:
                            data = {'uuid': str(r.uuid), 'payment_status': r.payment_status,
                                    'payment_confirmed_at': str(r.payment_confirmed_at),
                                    'payment_confirmed_by': r.payment_confirmed_by,
                                    'total_amount': r.total_amount,
                                    'invoice_number': r.invoice_number,
                                    'institutionName': institution.name,
                                    'institutionEmail': institution.email,
                                    'phone': institution.phone, 'due_date': str(
                                    entry_period.endDate.date() + timedelta(
                                        days=contract.due_date_days)),
                                    'entry_period_id': str(entry_period.id)}
                            invoice_list.append(data)

            return invoice_list
        else:
            return JSONResponse(content="Invoices Not Found", status_code=status.HTTP_404_NOT_FOUND)
    except Exception as e:
        print(e)
        return JSONResponse(content="Error: " + str(e),
                            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR)


@invoice_router.get('/institutions/{institution_id}/pending/invoices/')
async def fetch_institution_invoices(institution_id: int,
                                     inv_session: Session = Depends(get_session),
                                     user=Depends(auth_handler.get_current_user)):
    """ Endpoint to Fetch All  Invoices """
    try:
        invoice_list = []
        statement = select(Invoice).where(Invoice.deletedStatus == False,
                                          Invoice.payment_status == 'Pending')
        result = inv_session.exec(statement).all()

        if not result is None:
            for r in result:
                period_statement = select(EntryPeriod).where(EntryPeriod.id == r.entry_period_id,
                                                             EntryPeriod.deletedStatus == False)
                entry_period = inv_session.exec(period_statement).first()
                if not entry_period is None and entry_period.institution_id == institution_id:
                    ins_statement = select(Institution).where(
                        Institution.id == entry_period.institution_id,
                        Institution.deletedStatus == False)
                    institution = inv_session.exec(ins_statement).first()
                    if not institution is None:
                        cont_statement = select(Contract).where(
                            Contract.institution_id == institution.id,
                            Contract.deletedStatus == False)
                        contract = inv_session.exec(cont_statement).first()
                        if not contract is None:
                            data = {'uuid': str(r.uuid), 'payment_status': r.payment_status,
                                    'payment_confirmed_at': str(r.payment_confirmed_at),
                                    'payment_confirmed_by': r.payment_confirmed_by,
                                    'total_amount': r.total_amount,
                                    'invoice_number': r.invoice_number,
                                    'institutionName': institution.name,
                                    'institutionEmail': institution.email,
                                    'phone': institution.phone, 'due_date': str(
                                    entry_period.endDate.date() + timedelta(
                                        days=contract.due_date_days)),
                                    'entry_period_id': str(entry_period.id)}
                            invoice_list.append(data)

            return invoice_list
        else:
            return JSONResponse(content="Invoices Not Found", status_code=status.HTTP_404_NOT_FOUND)
    except Exception as e:
        print(e)
        return JSONResponse(content="Error: " + str(e),
                            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR)


@invoice_router.put('/invoices/{invoice_id}/upload/ebm_document/')
async def upload_invoice_ebm_attachment(invoice_id: int, file: UploadFile,
                                        inv_session: Session = Depends(get_session),
                                        user=Depends(auth_handler.get_current_user)):
    """ Endpoint to Upload Invoice EBM Document """
    try:
        print('Invoice Id')
        print(invoice_id)
        statement = select(Invoice).where(Invoice.id == invoice_id,
                                          Invoice.deletedStatus == False)
        result = inv_session.exec(statement).first()

        if not result is None:
            if os.path.exists(os.environ['FILE_SOURCE'] + '/' + 'EBMAttachments'):
                file_path = os.environ['FILE_SOURCE'] + '/' + 'EBMAttachments/' + str(
                    result.uuid) + '_' + file.filename
                with open(f'{file_path}', 'wb') as buffer:
                    shutil.copyfileobj(file.file, buffer)
            else:
                os.mkdir(os.environ['FILE_SOURCE'] + '/' + 'EBMAttachments')
                file_path = os.environ['FILE_SOURCE'] + '/' + 'EBMAttachments/' + str(
                    result.uuid) + '_' + file.filename
                with open(f'{file_path}', 'wb') as buffer:
                    shutil.copyfileobj(file.file, buffer)
            result.invoice_ebm = file_path
            inv_session.add(result)
            inv_session.commit()
            return result
        else:
            print('We couldn\'t find invoice')
            return JSONResponse(content="Invoice with " +str( invoice_id) + " Not Found",
                                status_code=status.HTTP_404_NOT_FOUND)
    except Exception as e:
        print(e)
        return JSONResponse(content="Error: " + str(e),
                            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR)


@invoice_router.get('/invoices/{invoice_id}/download/document/')
async def download_Invoice_EBM_document(invoice_id: int,
                                        inv_session: Session = Depends(get_session),
                                        user=Depends(auth_handler.get_current_user)):
    """ Endpoint to Download Invoice EBM Document """
    try:
        statement = select(Invoice).where(Invoice.id == invoice_id, Invoice.deletedStatus == False)
        result = inv_session.exec(statement).first()

        if not result is None:
            if not result.invoice_ebm is None and result.invoice_ebm != '':
                return FileResponse(result.invoice_ebm)
            else:
                return JSONResponse(content="Invoice EBM File Not Found",
                                    status_code=status.HTTP_400_BAD_REQUEST)
        else:
            return JSONResponse(content="Invoice with " + invoice_id + " Not Found",
                                status_code=status.HTTP_404_NOT_FOUND)
    except Exception as e:
        print(e)
        return JSONResponse(content="Error: " + str(e),
                            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR)


@invoice_router.delete('/invoices/{invoice_id}/remove/ebm_document/')
async def remove_invoice_ebm_document(invoice_id: int, inv_session: Session = Depends(get_session)):
    """ Endpoint to Remove Invoice EBM Document """
    try:
        statement = select(Invoice).where(Invoice.id == invoice_id, Invoice.deletedStatus == False)
        result = inv_session.exec(statement).first()

        if not result is None:
            if not result.invoice_ebm is None:
                if os.path.exists(result.invoice_ebm):
                    os.remove(result.invoice_ebm)
                    result.invoice_ebm = ''
                    inv_session.add(result)
                    inv_session.commit()
                    return JSONResponse(content="EBM File Removed Successfuly",
                                        status_code=status.HTTP_200_OK)
            else:
                return JSONResponse(content="Invoice EBM File Not Found",
                                    status_code=status.HTTP_400_BAD_REQUEST)
        else:
            return JSONResponse(content="Invoice with " + invoice_id + " Not Found",
                                status_code=status.HTTP_404_NOT_FOUND)
    except Exception as e:
        print(e)
        return JSONResponse(content="Error: " + str(e),
                            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    
@invoice_router.get('/invoices/unpaid/all')
async def fetch_unpaid_invoices(inv_session: Session = Depends(get_session),
                               user=Depends(auth_handler.get_current_user)):
    """ Endpoint to Return unpaid invoices """

    try:
        invoice_list=[]
        statement = select(Invoice).where(Invoice.deletedStatus == False,Invoice.payment_status!='Paid')
        results = inv_session.exec(statement).all()
        # for r in results:
        #     if r.payment_status != "Paid":
        #         invoice_list.append(r)
        return results

    except Exception as e:
        print(e)
        return JSONResponse(content="Error: " + str(e),
                            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
@invoice_router.get('/invoices/{period_id}/amount/correct',tags=['Invoice'])
async def get_invoice_total_amount(period_id:int,inv_session:Session=Depends(get_session),user=Depends(auth_handler.get_current_user)):
        try:
            inv_statement=select(Invoice).where(Invoice.entry_period_id==period_id,Invoice.deletedStatus==False)
            invoice=inv_session.exec(inv_statement).first()
            if not invoice is None: 
                amount=invoice.total_amount
                return {"total_amount":amount }       
            else:
                 return JSONResponse(
                            content="EntryPeriod with " + str(period_id) + " Not Found",
                            status_code=status.HTTP_404_NOT_FOUND,
            )
        except Exception as e:
            print(e)
        return JSONResponse(content='EntryPeriod with'+str(period_id))

@invoice_router.delete('/invoices/{invoice_id}/delete/invoice/')
async def delete_invoice_detail(invoice_id: int, inv_session: Session = Depends(get_session)):
    """ Endpoint to delete Invoice  detail """
    try:
        statement = select(Invoice).where(Invoice.id == invoice_id, Invoice.deletedStatus == False)
        result = inv_session.exec(statement).first()

        if not result is None:
            result.deletedStatus=True
            inv_session.add(result)
            inv_session.commit()

            return result
            
        else:
            return JSONResponse(content="Invoice with " + invoice_id + " Not Found",
                                status_code=status.HTTP_404_NOT_FOUND)
    except Exception as e:
        print(e)
        return JSONResponse(content="Error: " + str(e),
                            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
@invoice_router.get('/update_all_invoices/with_services/rate')
async def update_invoices_with_services_or_rate(session: Session = Depends(get_session),
                          user=Depends(auth_handler.get_current_user)):
    """ Endpoint to Update all invoices total amount """

    try:
        """ Get all invoices """
        statement = select(Invoice).where(Invoice.deletedStatus == False)
        result = session.exec(statement).all()

        if len(result) < 1:
            return JSONResponse(content=f'There are no invoices', status_code=status.HTTP_200_OK)
        for i in result:
            """ Get Invoice's entry period data """
            entry_period = session.exec(
                select(EntryPeriod).where(EntryPeriod.id == i.entry_period_id,
                                          EntryPeriod.deletedStatus == False)).first()
            """ Get Institution which the invoice belongs to """
            institution = session.exec(
                select(Institution).where(Institution.id == entry_period.institution_id,
                                          Institution.deletedStatus == False)).first()
            """ Get Institution's active contract """
            
            contract = session.exec(
                select(Contract).where(Contract.institution_id == institution.id,
                                       Contract.current == True,
                                       Contract.deletedStatus == False)).first()
            if contract:
                unitPrice = 0.0
                if institution.rate_type == "Universal":
                    check=False
                    if contract.services:
                        for service in contract.services:
                            if not service['service_rate'] is None:
                                check=True
                                break
                        if check:
                            unitPrice = service['service_rate']
                    else:
                        unitPrice = contract.rate
                else:
                    unitPrice = contract.rate

                """ Get all entries signed within the above entry period """
                emp_entry_statement = select(EmployeeEntry).where(
                    EmployeeEntry.entry_period_id == i.entry_period_id,
                    EmployeeEntry.deletedStatus == False, EmployeeEntry.signed == True)
                entries = session.exec(emp_entry_statement).all()

                if len(entries) > 0:
                    i.total_amount = update_invoice_amount(i.entry_period_id, float(unitPrice))
                    session.add(i)

        session.commit()
        return JSONResponse(content="All invoice's total amount updated successfully",
                            status_code=status.HTTP_200_OK)
    except Exception as e:
        print(e)
        return JSONResponse(content="Error: " + str(e),
                            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR)
#""" Get all entries signed within the above entry period """
"""
            emp_entry_statement = select(EmployeeEntry).where(
                EmployeeEntry.entry_period_id == i.entry_period_id,
                EmployeeEntry.deletedStatus == False, EmployeeEntry.signed == True)
            entries = session.exec(emp_entry_statement).all()

            if len(entries) > 0:
                if institution.rate_type == "Universal":
                    if contract.services:
                        for service in contract.services:
                            unitPrice=service['service_rate']
                    else:
                        unitPrice=contract.rate
                else:
                    unitPrice=contract.rate
                    i.total_amount = update_invoice_amount(i.entry_period_id, float(unitPrice))
                    session.add(i)
        session.commit()
        return JSONResponse(content="All invoice's total amount updated successfully",
                            status_code=status.HTTP_200_OK)
    except Exception as e:
        print(e)
        return JSONResponse(content="Error: " + str(e),
                            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR)
"""
                    
